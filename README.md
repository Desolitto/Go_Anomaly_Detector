# Go_Anomaly_Detector
## Задача 00: Передатчик  
"Итак, нам нужно самостоятельно реализовать протокол этого военного устройства," — сказала Луиза. — "Я уже упоминала, что он использует gRPC, так что давайте сделаем это."

Она показала базовую схему типов данных. Похоже, что каждое сообщение состоит всего из трех полей: 'session_id' в виде строки, 'frequency' в виде числа с плавающей точкой и текущий временной штамп в UTC.

Мы не знаем много о распределении, поэтому давайте реализуем это так, чтобы каждый раз, когда новый клиент подключается, ожидаемое значение и стандартное отклонение выбирались случайным образом. Для этого эксперимента давайте выберем среднее значение из интервала [-10, 10] и стандартное отклонение из интервала [0.3, 1.5].

При каждом новом подключении сервер должен генерировать случайный UUID (отправляемый как session_id) и новые случайные значения для среднего и стандартного отклонения. Все сгенерированные значения должны записываться в журнал сервера (stdout или файл). После этого он должен отправлять поток записей с вышеуказанными полями, где для каждого сообщения 'frequency' будет значением, выбранным случайным образом (выборка) из нормального распределения с этими стандартным отклонением и ожидаемым значением.

Необходимо описать схему в .proto файле и сгенерировать код из него. Также вы не должны вручную изменять сгенерированный код, просто импортируйте его.

## Задача 01: Обнаружение аномалий  
"Теперь к интересной части! Пока другие работают над gRPC сервером, давайте подумаем о клиенте. Я ожидаю, что gRPC клиент должен разрабатывать те же люди, что и сервер, чтобы протестировать его, так что давайте сосредоточимся на чем-то другом. Нам нужно обнаружить аномалии в распределении частоты!"

Итак, вы знаете, что получаете поток значений. С каждым новым входящим значением из потока ваш код должен уметь приближать среднее и стандартное отклонение из случайного распределения, сгенерированного на сервере. Конечно, предсказать это, глядя только на 3-5 значений, не совсем возможно, но после 50-100 это должно быть достаточно точно. Имейте в виду, что среднее и стандартное отклонение генерируются для каждого нового подключения, поэтому вы не должны перезапускать клиент в процессе. Также значения не должны накапливаться в памяти, поэтому вы можете рассмотреть возможность использования sync.Pool для легкого повторного использования.

Работая над этой задачей, вы можете временно забыть о gRPC и протестировать код, просто отправив ему последовательность значений через stdin.

Ваш код клиента должен периодически записывать в журнал, сколько значений было обработано до сих пор, а также предсказанные значения среднего и стандартного отклонения.

Через некоторое время, когда ваш клиент решит, что предсказанные параметры распределения достаточно хороши (вы можете выбрать этот момент самостоятельно), он должен автоматически перейти в стадию обнаружения аномалий. Здесь появляется еще один параметр - коэффициент аномалии стандартного отклонения. Таким образом, ваш клиент должен принимать параметр командной строки (пусть это будет '-k') с коэффициентом типа float.

Входящая частота считается аномалией, если она отличается от ожидаемого значения более чем на k * STD в любую сторону (влево или вправо, так как распределение симметрично). Вы можете прочитать больше о том, как это работает, по ссылкам из 4 главы.

На данный момент вам следует просто записывать найденные аномалии в журнал.

## Задача 02: Отчет  
"Поскольку генерал ничего не знает о нашем научном устройстве, давайте храним все аномалии, которые мы встречаем, в базе данных, и тогда он сможет посмотреть на это через какой-то интерфейс, который у них есть," — кажется, Луиза больше заботится о данных, чем о генерале.

Итак, давайте научимся записывать записи данных в PostgreSQL. Обычно считается плохой практикой просто писать обычные SQL-запросы в коде при работе с высокозащищенными средами (вы можете прочитать о SQL-инъекциях по ссылкам из 4 главы). Давайте использовать ORM. В случае PostgreSQL есть два самых очевидных выбора (эти ссылки также приведены ниже), но вы можете выбрать любой другой. Главная идея здесь — не иметь строк с SQL-кодом в ваших источниках.

Вам нужно будет описать вашу запись (session_id, frequency и временной штамп) как структуру в Go, а затем использовать ее вместе с ORM для отображения в столбцы базы данных.

## Задача 03: Все вместе  
Хорошо, когда у нас есть передатчик, приемник, обнаружение аномалий и ORM, мы можем соединить все это вместе и объединить в полный проект.

Итак, если вы запускаете сервер и клиента (PostgreSQL уже должен работать на вашем компьютере), ваш клиент подключится к серверу и получит поток записей, которые затем:

Первое, использовать для реконструкции распределения (mean/STD)  
Второе, через некоторое время начать обнаруживать аномалии на основе предоставленного коэффициента аномалии стандартного отклонения (я предлагаю выбрать его достаточно большим для этого эксперимента, чтобы аномалии не происходили слишком часто)  
Третье, все аномалии должны быть записаны в базу данных PostgreSQL с использованием ORM  
Если Луиза права, эти аномалии могут стать ключом к первому контакту с инопланетянами. Но это также довольно прямой подход для случаев, когда вам нужно обнаружить аномалии в потоке данных, для чего Go может быть эффективно использован.